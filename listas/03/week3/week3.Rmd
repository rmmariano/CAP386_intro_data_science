---
title: "Tidy Data Example: Hot Dogs in Baltimore"
output:   
  github_document:
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Reading Data

Do the download of the CSV data from https://data.baltimorecity.gov/dataset/Food-Vendor-Locations/bqw3-z52q/data

```{r}
vendors <- "https://data.baltimorecity.gov/api/views/bqw3-z52q/rows.csv?accessType=DOWNLOAD"

download.file(vendors, destfile = "../TempData/BFood.csv", method="curl")

if (file.exists("../TempData/BFood.csv")) {
  tam <- file.info("../TempData/BFood.csv")$size
  paste("File downloaded, ",tam," bytes")
} else {
  "Error downloading file!"
}
```

Read the CSV keeping the same header:

```{r}
# Let's live dangerously.
bVendors <- read.csv(file="../TempData/BFood.csv", header=TRUE, sep=",", stringsAsFactors=FALSE)

str(bVendors)
```


## Selecting Variables and Creating Factors

Remove the column <tt>Id</tt> and tranform the <tt>LicenseNum</tt> column in a factor from <tt>bVendors</tt>:

```{r}
bVendors$Id <- NULL
bVendors$LicenseNum <- as.factor(bVendors$LicenseNum)
```

<tt>bVendors$St</tt> looks suspicious... let's check it:

```{r}
bVendors$St <- as.factor(bVendors$St)
str(bVendors$St)

bVendors$St <- NULL
```

The name for variable <tt>Location.1</tt> is ugly, so change to <tt>location</tt>:

```{r}
names(bVendors)[names(bVendors) == "Location.1"] <- "location"
str(bVendors)
```


## Parsing Location

```{r}
oneLoc <- "Towson 21204\n(39.28540000000, -76.62260000000)"
```

<tt>strsplit</tt> returns a matrix, so compact in a vector with <tt>unlist</tt>:

```{r}
locV1 <- unlist(strsplit(oneLoc, "\n"))

locV1

latLong <- locV1[2]
latLongS <- unlist(strsplit(locV1[2], ","))

latLongS

lat <- as.numeric(gsub("^.",'', latLongS[1]))
long <- as.numeric(gsub(".$",'', latLongS[2]))

lat
long
```

That was truly horrible. Let's try another way:

```{r}
oneLoc <- "Towson 21204\n(39.28540000000, -76.62260000000)"

tempS <- unlist(regmatches(oneLoc,gregexpr("[0-9.]+", oneLoc)))

tempS
```

```{r}
lat <- as.numeric(tempS[2])
long <- as.numeric(tempS[3])
```

```{r}
paste("lat =", lat, " long = ", long)
```

Now for the whole dataframe:

```{r}
tempS <- regmatches(bVendors$location, gregexpr("[0-9.]+", bVendors$location))

lats <- vector(length = nrow(bVendors), mode = "numeric")
longs <- vector(length = nrow(bVendors), mode = "numeric")

for(i in 1:nrow(bVendors)) {
  lats[i] <- as.numeric(tempS[[i]][2])
  longs[i] <- as.numeric(tempS[[i]][3])
}

bVendors$lat <- lats
bVendors$long <- longs

str(bVendors)
```

Worried about the values shown? Don't be. 
<tt>subset</tt> function create a subset of the <tt>bVendors</tt> only with the columns: <tt>location</tt>, <tt>lat</tt> and <tt>long</tt>.
<tt>head</tt> function will show only the six first rows:

```{r}
head(subset(bVendors, select = c(location, lat, long)))
```


## Now for the exercises!

```{r}
bVendors$hotdog <- grepl("Hot dog", bVendors$ItemsSold)

head(subset(bVendors, select = c(ItemsSold, hotdog)))
```


## R Exercises	

* I want to get all variations of "hot dog", including "frank". 
With <tt>ignore.case</tt> we will get all cases that match with "hot dog" or "frank" in both cases (lower or upper):
  
```{r}
bVendors$hotdog <- grepl("hot dog|frank", bVendors$ItemsSold, ignore.case = TRUE)

head(subset(bVendors, select = c(ItemsSold, hotdog)))
```


* Now I want to get all variations of "pizza":
  
```{r}
bVendors$pizza <- grepl("pizza", bVendors$ItemsSold, ignore.case = TRUE)

head(subset(bVendors, select = c(ItemsSold, pizza)))
```

* Given a location, we want to extract the name of the town, so first we split the location, getting the part before the <tt>\\n</tt>:

```{r}
#one_location <- "Towson 21204\n(39.28540000000, -76.62260000000)"
one_location <- "Owings Mill 21117\n(39.29860000000, -76.61280000000)"

location_vector <- unlist(strsplit(one_location, "\n"))

location_vector
```

Getting the name of the town and zip code:

```{r}
city_and_zip_code <- location_vector[1]

city_and_zip_code
```

We want to separate both, so first we split it by white space and convert to list:

```{r}
city_and_zip_code_char <- unlist(strsplit(city_and_zip_code, " "))

city_and_zip_code_char

city_and_zip_code_list = as.vector(city_and_zip_code_char, mode="list") 

city_and_zip_code_list

```

So get the last index of the list:

```{r}
last_index = length(city_and_zip_code_list)

last_index
```

With this index, now we can separate the name of the city and the zip code, where the zip code is the last position and the name of the town is the rest:

```{r}
zip_code = city_and_zip_code_list[last_index]

# zip_code is a list with one string, so we join it in a string
zip_code = paste(zip_code, collapse = '')

# remove the zip code of the list
city_and_zip_code_list[last_index] <- NULL

name_town = city_and_zip_code_list

name_town

zip_code
```

If the name of the town have more than one word, so we need to assemble them again:

```{r}
name_town = paste(name_town, collapse = ' ')

name_town
```

* Now we will do it for the entire dataframe:

```{r}
# creating the auxiliary vectors
name_town_vector <- vector(length = nrow(bVendors), mode = "character")
zip_code_vector <- vector(length = nrow(bVendors), mode = "character")


for(i in 1:nrow(bVendors)) {
  location_vector = unlist(strsplit(bVendors$location[i], "\n"))
  city_and_zip_code = location_vector[1]
  
  city_and_zip_code_char <- unlist(strsplit(city_and_zip_code, " "))
  city_and_zip_code_list = as.vector(city_and_zip_code_char, mode="list") 
  
  # get the last index in list
  last_index = length(city_and_zip_code_list)
  
  # get the zip code from list
  zip_code = city_and_zip_code_list[last_index]
  
  # zip_code is a list with one string, so we join them in a string
  zip_code = paste(zip_code, collapse = '')
  
  # remove the zip code of the list
  city_and_zip_code_list[last_index] <- NULL
  
  name_town = city_and_zip_code_list
  
  # if the name of town has more than one word, join them
  name_town = paste(name_town, collapse = ' ')
  
  name_town_vector[i] = name_town
  zip_code_vector[i] = zip_code
}

```

```{r}
head(name_town_vector)
```

```{r}
head(zip_code_vector)
```

```{r}
str(bVendors)
```

Put the vectors with name of town and zip code in the <tt>bVendors</tt>:

```{r}
bVendors$name_town <- name_town_vector
bVendors$zip_code <- zip_code_vector

str(bVendors)
```

```{r}
head(subset(bVendors, select = c(name_town, zip_code, location)))
```

It is all OK.